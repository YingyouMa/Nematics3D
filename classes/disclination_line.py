import numpy as np 

from ..disclination import add_mid_points_disclination, calc_coord, defect_rotation
from .smoothened_line import SmoothenedLine
from ..general import array_from_single_or_list, sort_line_indices, get_plane, get_tangent

class DisclinationLine:
    #! Consider period for cross
    """
    Disclination_line class represents a disclination line.


    """
    def __init__(self, defect_indices, box_size_periodic,
                       is_sorted=True, origin=(0,0,0), space_index_ratio=1, is_add_mid=False):   
        '''
        defect_indices : array, (M,3)
                         The array that includes all the indices of defects.
                         For each defect, one of the indices should be integer and the rest should be half-integer.
                         Usually defect_indices are generated by defect_defect() in this module.

        box_size_periodic : array of three floats, or one float, optional
                            The number of indices in each dimension, x, y, z.
                            If box_size is x, it will be interprepted as [x,x,x].
                            If one of the boundary is not periodic, the corresponding value here is np.inf.
                            For example, if the box is periodic in x and y dimension, and the possible maximum index is X and Y,
                            box_size_periodic should be [X+1, Y+1, np.inf].
                            Default is [np.inf, np.inf, np.inf], which means the function only return the point itself.

        is_sorted : bool, optional
                    if the defects are already sorted that the neighboring defects have the minimum distance.
                    Default is True. Because this class is usually used after defect_classify_into_lines() and extract_lines() 

        origin : array of three floats, optional
                 Origin of the line, translating the whole line in real space
                 Default is (0, 0, 0), as the line is not translated 

        space_index_ratio : float or array of three floats, optional
                            Ratio between the unit of real space to the unit of grid indices.
                            If the box size is N x M x L and the size of grid of n and S is n x m x l,
                            then space_index_ratio should be (N/n, M/m, L/l).
                            If a single float x is provided, it is interpreted as (x, x, x).
                            Default is 1.

        Dependencies
        ------------
        - NumPy: 1.22.0
        '''
        if is_sorted == False:
            defect_indices = sort_line_indices(defect_indices) 

        box_size_periodic = array_from_single_or_list(box_size_periodic)

        if np.linalg.norm(defect_indices[0] - defect_indices[-1]) == 0:
            self._end2end_category = 'loop'
            self._defect_indices = defect_indices[:-1]
        else:
            defect1 = defect_indices[0].copy()
            defect2 = defect_indices[-1].copy()
            defect1 = np.where(box_size_periodic==np.inf, defect1, defect1%box_size_periodic)
            defect2 = np.where(box_size_periodic==np.inf, defect2, defect2%box_size_periodic)
            if np.linalg.norm(defect1 - defect2) == 0:
                self._end2end_category = 'cross'
                self._defect_indices = defect_indices[:-1]
            else:
                self._end2end_category = 'seg'
                self._defect_indices = defect_indices

        self._origin = origin
        self._space_index_ratio = array_from_single_or_list(space_index_ratio)
        self._box_size_periodic = box_size_periodic
        self._box_size_periodic_coord = box_size_periodic * self._space_index_ratio
        self._defect_num = np.shape(self._defect_indices)[0]

        if len(np.shape([space_index_ratio])) == 1:
            space_index_ratio = (space_index_ratio, space_index_ratio, space_index_ratio)

        if is_add_mid:
            self._defect_indices_full = add_mid_points_disclination(self._defect_indices, is_loop=self._end2end_category=='loop')
        else:
            self._defect_indices_full = self._defect_indices
        
        self._defect_coord = calc_coord(self._defect_indices_full, 
                                         origin=origin, space_index_ratio=space_index_ratio)
        self._origin = origin
        self._space_index_ratio = space_index_ratio


    def update_defect_coord(self, origin=(0,0,0), space_index_ratio=1):

        self._defect_coord = calc_coord(self._defect_indices_full, 
                                         origin=origin, space_index_ratio=space_index_ratio)

        self._origin = origin
        self._space_index_ratio = space_index_ratio 


    def update_norm(self):
        self._norm = get_plane(self._defect_coord)
        return self._norm
    

    def update_center(self):
        self._center = np.average(self._defect_indices, axis=0)
        return self._center
    

    def update_smoothen(self,
                        window_ratio=None, window_length=21, order=3, N_out_ratio=3):
        if self._end2end_category == 'loop':
            smoothen_mode = 'wrap'
        else:
            smoothen_mode = 'interp'

        if window_ratio != None:
            window_length = None

        output = SmoothenedLine(self._defect_coord, 
                                window_ratio=window_ratio, window_length=window_length, 
                                order=order, N_out_ratio=N_out_ratio, mode=smoothen_mode,
                                is_keep_origin=False) 
        
        self._defect_coord_smooth_obj = output
        self._defect_coord_smooth = output._output

        return output._output
    

    def update_rotation(self, n, num_shell=1, method='plane'):
        self._Omega = defect_rotation(self._defect_indices, n, 
                                      num_shell=num_shell, method=method, box_size_periodic=self._box_size_periodic)
        return self._Omega
    
    
    def update_gamma(self, n=0, num_shell=1):

        if hasattr(self, '_Omega'):
            Omega = self._Omega
        else:
            Omega = self.update_rotation(n, num_shell=num_shell)

        if hasattr(self, '_norm'):
            norm = self._norm
        else:
            norm = self.update_norm()

        norm = np.broadcast_to(norm, (self._defect_num,3))
        self._gamma = np.arccos(np.abs(np.einsum('ia, ia -> i', norm, Omega))) / np.pi * 180

        return self._gamma
    
    
    def update_geometry(self, is_smooth=True):

        if is_smooth:
            if hasattr(self, '_defect_coord_smooth'):
                if self._defect_coord_smooth_obj._N_out_ratio == 1:
                    points = self._defect_coord_smooth
                else:
                    print('There are more points in the smooth line')
                    print('Start to re-smooth it with N_out_ratio=1')
                    print(f'window_length={self._defect_coord_smooth_obj._window_length}')
                    print(f'order={self._defect_coord_smooth_obj._order}')
                    print(f'mode={self._defect_coord_smooth_obj._mode}')
                    
                    points = SmoothenedLine(self._defect_coord, 
                                            window_length=self._defect_coord_smooth_obj._window_length, 
                                            order=self._defect_coord_smooth_obj._order, 
                                            N_out_ratio=1, 
                                            mode=self._defect_coord_smooth_obj._mode,
                                            is_keep_origin=False)._output
                    print('Done!')

            else:
                print('The line has not been smoothened')
                print('Use original data instead')
                points = self._defect_coord
        else:
            points = self._defect_coord

        is_periodic = self._end2end_category == 'loop'

        tangents = get_tangent(points, is_periodic=is_periodic, is_norm=False)
        tangents_size = np.linalg.norm(tangents, axis=1, keepdims=True)
        tangents = tangents / tangents_size

        dT_ds = get_tangent(tangents, is_periodic=is_periodic, is_norm=False)
        dT_ds_size = np.linalg.norm(dT_ds, axis=1, keepdims=False)
        curvatures = dT_ds_size / tangents_size[:,0]

        length = np.sum(tangents_size, axis=0)[0]

        self._tangent = tangents
        self._curvature = curvatures
        self._length = length

    
    def update_beta(self, n=0):

        if hasattr(self, '_Omega'):
            Omega = self._Omega
        else:
            Omega = self.update_rotation(n)

        if not hasattr(self, '_tangent'):
            self.update_geometry()
        tangent = self._tangent

        self._beta = np.arccos(np.einsum('ia, ia -> i', tangent, Omega)) / np.pi * 180

        return self._beta


    def figure_init(self, is_wrap=False, is_smooth=True,
                    tube_radius=0.5, tube_opacity=0.5, tube_color=(0.5,0.5,0.5), tube_sides=6,
                    is_new=True, bgcolor=(1,1,1), fig_size=(1920, 1360),
                    color_beta=True
                    ):
        #! plot_norm
        #! color_beta
        '''

        '''
        from mayavi import mlab

        if is_smooth:
            if hasattr(self, '_defect_coord_smooth'):
                line_coord = self._defect_coord_smooth
            else:
                print('the line has not been smoothened')
                print('use original data instead')
                line_coord = self._defect_coord
        else:
            line_coord = self._defect_coord

        if is_new:
            mlab.figure(bgcolor=bgcolor, size=fig_size)

        if not is_wrap:
            # self.update_beta()
            # figure = mlab.plot3d(*(points.T), self.beta,
            #                         tube_radius=tube_radius, opacity=tube_opacity, tube_sides=tube_sides)
            figure = mlab.plot3d(*(line_coord.T), 
                                    tube_radius=tube_radius, opacity=tube_opacity, color=tube_color, 
                                    tube_sides=tube_sides)
            figures = [figure]
        else:

            line_coord = np.where( self._box_size_periodic_coord==np.inf, 
                                  line_coord, line_coord%self._box_size_periodic_coord )
            diff = line_coord[1:] - line_coord[:-1]
            diff = np.linalg.norm(diff, axis=-1)
            end_list = np.where(diff>1)[0] + 1
            end_list = np.concatenate([[0], end_list, [len(line_coord)]])

            figures = []
            for i in range(len(end_list)-1):
                points = line_coord[end_list[i]:end_list[i+1]]
                figure = mlab.plot3d(*(points.T), 
                                     tube_radius=tube_radius, opacity=tube_opacity, color=tube_color, tube_sides=tube_sides)
                figures.append(figure)
                
        if not is_new:
            figure.parent.parent.parent.parent.parent.scene.background = bgcolor

        self._figures = figures
        
    def generate_dict_figure_simplify(self, idx):
        dict_figure_simplify = {'bgcolor':      (lambda: self._figures[idx].parent.parent.parent.parent.parent.scene, 'background'),
                                'tube_radius':  (lambda: self._figures[idx].parent.parent.filter, 'radius'),
                                'tube_opacity': (lambda: self._figures[idx].actor.property, 'opacity'),
                                'tube_sides':   (lambda: self._figures[idx].parent.parent.filter, 'number_of_sides'),
                                'tube_color':   (lambda: self._figures[idx].actor.property, 'color'),
                                'tube_spec':    (lambda: self._figures[idx].actor.property, 'specular'),
                                'tube_spec_col': (lambda: self._figures[idx].actor.property, 'specular_color'),
                                'tube_spec_pow': (lambda: self._figures[idx].actor.property, 'specular_power')
                                        }
        return dict_figure_simplify

    def figure_check_parameter(self, *args):
        for arg in args:
            dict_figure_simplify = self.generate_generate_dict_figure_simplify(0)
            temp = dict_figure_simplify.get(arg)
            obj = temp[0]()
            attr = temp[1]
            print(arg + ' : ' + str(getattr(obj,attr)))

    def figure_update(self, **kwargs):
        for attr in kwargs.keys():
            for idx in range(len(self._figures)):
                dict_figure_simplify = self.generate_dict_figure_simplify(idx)
                obj = dict_figure_simplify.get(attr)[0]()
                attr_final = dict_figure_simplify.get(attr)[1]
                setattr(obj, attr_final, kwargs.get(attr))
        




# def plot_loop(
#             loop_coord, 
#             tube_radius=0.25, tube_opacity=0.5, tube_color=(0.5,0.5,0.5), if_add_head=True,
#             if_norm=False, 
#             norm_coord=[None,None,None], norm_color=(0,0,1), norm_length=20, 
#             norm_opacity=0.5, norm_width=1.0, norm_orient=1,
#             print_load_mayavi=False
#             ):

#     if print_load_mayavi == True:
#         now = time.time()
#         from mayavi import mlab
#         print(f'loading mayavi cost {round(time.time()-now, 2)}s')
#     else:
#         from mayavi import mlab

#     if if_add_head==True:
#         loop_coord = np.concatenate([loop_coord, [loop_coord[0]]])

#     mlab.plot3d(*(loop_coord.T), tube_radius=tube_radius, opacity=tube_opacity, color=tube_color)

#     if if_norm == True:
#         loop_N = get_plane(loop_coord) * norm_orient
#         loop_center = loop_coord.mean(axis=0)
#         for i, coord in enumerate(norm_coord):
#             if coord != None:
#                 loop_center[i] = coord
#         mlab.quiver3d(
#         *(loop_center), *(loop_N),
#         mode='arrow',
#         color=norm_color,
#         scale_factor=norm_length,
#         opacity=norm_opacity,
#         line_width=norm_width
#         ) 

# def update_length(self):
#     self._length = np.linalg.norm(self._defect_coord[1:] - self._defect_coord[:-1], axis=-1).sum()
#     return self._length
